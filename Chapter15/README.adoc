= 第十五章  面向对象程序设计
ifdef::env-github[]
:imagesdir:
 https://gist.githubusercontent.com/path/to/gist/revision/dir/with/all/images
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
ifndef::env-github[]
:imagesdir: ./
endif::[]
:toc:
:toc-placement!:

toc::[]

# OOP概述

* *面向对象程序设计* 的核心思想是数据抽象、继承和动态绑定

* *继承*（inheritance）
** 通过继承联系在一起的类构成一种层次关系
** 通常在层次关系的根部有一个 *基类*（base class）
** 其他类则直接或间接地从基类继承而来，这些继承得到的类称为 *派生类* （derived class）
** 基类负责定义在层次关系中所有类共同拥有地成员，而每个派生类定义各自特有的成员
** 对于某些，基类希望它的派生类各自定义适合自身的版本，此时基类将这些函数声明成 *虚函数*（virtual function）
** 派生类必须通过使用 *类派生列表*（class derivation list）明确指出它是从哪个（哪些）基类继承而来
*** 类派生列表的形式: 首先是冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符（`public` 、`protected` 、`private`）: `class Bulk_quote : public Quote{};`
*** 派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上 `virtual` 关键字，也可以不加。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个 `override` 关键字

* *动态绑定*（dynamic binding）: 也称为运行时绑定（run-time binding）
** 可以使用同一段代码可以分别处理基类和派生类的对象，例如函数运行时根据实参属于基类还是派生类，选择函数版本
** 在C++语言中，当我们使用 *基类的引用（或指针）* 调用一个虚函数时将发生动态绑定

[source,c++]
----
///继承
//Quote的对象表示按原价销售的书籍
class Quote{
    public:
        std::string isbn() const;
        virtual double net_price(std::size_t n)const;
};

//Quote派生出另一个名为Bulk_quote的类，表示可以打折销售的书籍
//因为Bulk_quote在其派生列表中使用了public关键字，所以完全可以把Bulk_quote的对象当成Quote的对象来使用
class Bulk_quote : public Quote{
    public:
        double net_price(std::size_t n)const override;
};

///动态绑定
double price_total(ostream &os, const Quote &item, size_t n){
    //根据传入item实参对象类型调用Quote::net_price或Bulk_quote::net_price
    double ret = item.net_price(n);
    os << "ISBN: "<<item.isbn()     //调用Quote::isbn
       << "# sold: "<<n<<" total due: "<<ret<<endl;
    return ret;
}

//basic的类型是Quote；bulk的类型是Bulk_quote
//使用基类的引用（或指针）调用一个虚函数时将发生动态绑定
print_total(cout, basic,20);    //调用Quote::net_price
print_total(cout, basic,20);    //调用Bulk_quote::net_price
----

# 定义基类和派生类

## 定义基类

* 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

* 成员函数与继承
** 基类的两类成员函数:
*** 一种是基类希望派生类直接继承而不要改变的函数，该函数解析过程发生在编译时而非运行时
*** 另一种是基类希望其派生类进行覆盖的函数，常定义为虚函数
** 基类通过在其成员函数的声明语句前加上关键字virtual，且当使用指针或引用调用虚函数时，使得该函数执行动态绑定
** 任何构造函数之外的非静态函数都可以是虚函数
** 关键字 `virtual` 只能出现在类内部的声明语句之前，而不能用于类外部的函数定义
** 如果基类把一个函数声明称虚函数，则该函数在派生类中隐式地也是虚函数

* 访问控制与继承
** 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员: 派生类可以访问公有成员、受保护成员，不能访问私有成员
** `public`
** `protected`: 基类和其派生类还有友元可以访问
** `private`: 只有基类本身和友元可以访问

[source,c++]
----
class Quote
{
public:
	Quote() = default;
	Quote(const std::string &b, double p) :
		bookNo(b), price(p){}
	std::string isbn() const { return bookNo; }
	virtual double net_price(std::size_t n) const { return n * price; }

	virtual ~Quote() = default;

private:
	std::string bookNo;

protected:
	double  price = 0.0;

};
----

## 定义派生类

* 派生类必须通过类派生列表明确指出它是从哪个基类继承而来。形式: 冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有一下三种访问说明符的一个: `public`、`protected`、`private`
* 派生类必须将其继承而来的成员函数中需要覆盖的那些（`virtual`）重新声明

# 虚函数



# 抽象基类


# 访问控制与继承