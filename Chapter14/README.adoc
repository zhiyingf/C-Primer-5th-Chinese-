= 第十四章  重载运算符与类型转换
ifdef::env-github[]
:imagesdir:
 https://gist.githubusercontent.com/path/to/gist/revision/dir/with/all/images
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
ifndef::env-github[]
:imagesdir: ./
endif::[]
:toc:
:toc-placement!:

toc::[]

# 基本概念

* *重载运算符* 是具有特殊名字地函数: 由关键字 `operator` 和其后要定义的运算符共同组成
* 重载运算符函数的参数数量与该运算符作用的运算对象数量一致。除了重载的函数调用运算符 `operator()` 之外，其它重载运算符不能含有默认参。
** 可以从运算符函数的参数数量判断（ `+ , - , \* , &` ）是一元操作符还是二元操作符

[NOTE]
====
当一个重载的运算符是成员函数时，`this` 绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。
====

* 运算符函数，要么是类的成员，要么至少含有一个类类型的参数
* 只能重载已有的运算符，无权发明新的运算符号
* 重载运算符的优先级和结合律与对应的内置运算符保持一致，其返回类型应该与内置版本的返回类型兼容。
** 逻辑运算符和关系运算符应该返回 `bool`
** 算术运算符应该返回一个类类型的值
** 赋值运算符和复合运算符则应该返回左侧运算对象的一个引用




image::img/table14-1.png[alt=table, width=1201,align=center]

CAUTION: 通常情况下，不应该重载逗号、取地址、逻辑与、逻辑或运算符。
前两者是因为C++语言已经定义了这两种运算符用于类类型对象时的特殊含义。后两者是因为重载运算符版本无法保持求值顺序和短路性质。

TIP: 尽量明智地使用运算符重载，使得内置的运算符和类操作之间存在逻辑映射关系。重载的运算符应该继承而非违背其内置版本的含义。 


*直接调用一个重载的运算符函数*

[source,c++]
----
//一个非成员运算符函数的等价调用
//传入data1作为第一个实参，传入data2作为第二个实参
data1 + data2;
operator+(data1,data2);

//显式的调用成员运算符函数
data1 += data2;
data1.operator+=(data2);
----

* 将重载运算符定义为成员函数还是普通非成员函数
** 赋值(`=`)、下标(`[]`)、调用(`()`)和成员访问箭头(`\->`)运算符必须是成员
** 复合赋值运算符应该是成员
** 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增(`++`)、递减(`--`)和解引用运算符(`*`)，应该是成员运算符
** 具有对称性的运算符可能转换任意一端的运算对象，应该设置为普通的非成员函数

# 输入和输出运算符(定义类的IO操作)

## 重载输出运算符 `<<`

* 第一个形参通常是一个非常量的ostream对象的引用。非常量是因为向流中写入会改变其状态；而引用是因为我们无法复制一个 `ostream` 对象
* IO运算符必须是非成员函数，一般被声明为友元 `friend`

## 重载输入运算符 `>>`

* 第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用
* 输入运算符必须处理输入可能失败的情况，而输出运算符不需要

* 输入时错误
** 当流含有错误类型的数据时读取操作可能失败
** 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败

[source,c++]
----
class Sales_data{
    //... ...
    friend std::istream& operator>>(std::istream&, Sales_data&);
	friend std::ostream& operator<<(std::ostream&, const Sales_data&);
    //... ...
}

std::ostream& operator<<(std::ostream &out, const Sales_data &item)
{
	out << item.isbn() << " " << item.units_sold << " " << item.revenue << " " << item.avg_price();
	return out;
}

istream &operator>>(istream &is, Sales_data &item)
{
	double price;  // no need to initialize; we'll read into price before we use it
    //如果读取失败，price未定义
	is >> item.bookNo >> item.units_sold >> price;
	if (is)        // check that the inputs succeeded
    	item.revenue = item.units_sold * price;
	else
    	item = Sales_data(); // input failed: give the object the default state
	return is;
}

//test
std::cout << book << std::endl;
----

# 算术和关系运算符

* 把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换，形参都是常量的引用
* 如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符

# 赋值运算符



# 下标运算符



# 递增和递减运算符



# 成员访问运算符



# 函数调用运算符


# 重载、类型转换与运算符




